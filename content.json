[{"title":"php的简洁之道","date":"2017-12-25T12:10:32.000Z","path":"2017/12/25/php的简洁之道/","text":"前言前几天在GitHub看到一篇写PHP简洁之道的译文，觉得还不错，所以转在了自己的博客中，只不过有一些地方好像没有翻译，再加上排版上的一些小问题，所以决定自己翻译一遍。原文地址:https://github.com/jupeter/clean-code-php 变量 使用更有意义和更加直白的命名方式 不友好的: 1$ymdstr = $moment-&gt;format('y-m-d'); 友好的: 1$currentDate = $moment-&gt;format('y-m-d'); 对于同一实体使用相同变量名 不友好的: 12345&gt;getUserInfo();&gt;getUserData();&gt;getUserRecord();&gt;getUserProfile();&gt; &gt; 友好的: 12&gt;getUser();&gt; 使用可以查找到的变量 我们读的代码量远比我们写过的多。因此，写出可阅读和便于搜索的代码是及其重要的。在我们的程序中写出一些难以理解的变量名到最后甚至会让自己非常伤脑筋。因此，让你的名字便于搜索吧。 不友好的: 123&gt;// 这里的448代表什么意思呢？&gt;$result = $serializer-&gt;serialize($data, 448);&gt; &gt; 友好的: 12&gt;$json = $serializer-&gt;serialize($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT | &gt;JSON_UNESCAPED_UNICODE);&gt; 使用解释型变量 不友好的 123456&gt;$address = 'One Infinite Loop, Cupertino 95014';&gt;$cityZipCodeRegex = '/^[^,]+,\\s*(.+?)\\s*(\\d&#123;5&#125;)$/';&gt;preg_match($cityZipCodeRegex, $address, $matches);&gt;&gt;saveCityZipCode($matches[1], $matches[2]);&gt; &gt; 不至于那么糟糕的: 稍微好一些，但是这取决于我们对正则的熟练程度。 1234567&gt;$address = 'One Infinite Loop, Cupertino 95014';&gt;$cityZipCodeRegex = '/^[^,]+,\\s*(.+?)\\s*(\\d&#123;5&#125;)$/';&gt;preg_match($cityZipCodeRegex, $address, $matches);&gt;&gt;[, $city, $zipCode] = $matches;&gt;saveCityZipCode($city, $zipCode);&gt; &gt; 友好的: 通过对子模式的重命名减少了我们对正则的熟悉和依赖程度。 123456&gt;$address = 'One Infinite Loop, Cupertino 95014';&gt;$cityZipCodeRegex = '/^[^,]+,\\s*(?&lt;city&gt;.+?)\\s*(?&lt;zipCode&gt;\\d&#123;5&#125;)$/';&gt;preg_match($cityZipCodeRegex, $address, $matches);&gt;&gt;saveCityZipCode($matches['city'], $matches['zipCode']);&gt; 嵌套无边，回头是岸 太多的if else嵌套会让你的代码难以阅读和维护。更加直白的代码会好很多。 demo1 不友好的: 12345678910111213141516171819202122&gt;function isShopOpen($day): bool&gt;&#123;&gt; if ($day) &#123;&gt; if (is_string($day)) &#123;&gt; $day = strtolower($day);&gt; if ($day === 'friday') &#123;&gt; return true;&gt; &#125; elseif ($day === 'saturday') &#123;&gt; return true;&gt; &#125; elseif ($day === 'sunday') &#123;&gt; return true;&gt; &#125; else &#123;&gt; return false;&gt; &#125;&gt; &#125; else &#123;&gt; return false;&gt; &#125;&gt; &#125; else &#123;&gt; return false;&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 12345678910111213&gt;function isShopOpen(string $day): bool&gt;&#123;&gt; if (empty($day)) &#123;&gt; return false;&gt; &#125;&gt;&gt; $openingDays = [&gt; 'friday', 'saturday', 'sunday'&gt; ];&gt;&gt; return in_array(strtolower($day), $openingDays, true);&gt;&#125;&gt; &gt; demo2 不友好的:1234567891011121314151617&gt;function fibonacci(int $n)&gt;&#123;&gt; if ($n &lt; 50) &#123;&gt; if ($n !== 0) &#123;&gt; if ($n !== 1) &#123;&gt; return fibonacci($n - 1) + fibonacci($n - 2);&gt; &#125; else &#123;&gt; return 1;&gt; &#125;&gt; &#125; else &#123;&gt; return 0;&gt; &#125;&gt; &#125; else &#123;&gt; return 'Not supported';&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 12345678910111213&gt;function fibonacci(int $n): int&gt;&#123;&gt; if ($n === 0 || $n === 1) &#123;&gt; return $n;&gt; &#125;&gt;&gt; if ($n &gt; 50) &#123;&gt; throw new \\Exception('Not supported');&gt; &#125;&gt;&gt; return fibonacci($n - 1) + fibonacci($n - 2);&gt;&#125;&gt; 避免使用不合理的变量名&gt; 别让其他人去猜你的变量名的意思。更加直白的代码会好很多。 不友好的: 12345678910111213&gt;$l = ['Austin', 'New York', 'San Francisco'];&gt;&gt;for ($i = 0; $i &lt; count($l); $i++) &#123;&gt; $li = $l[$i];&gt; doStuff();&gt; doSomeOtherStuff();&gt; // ...&gt; // ...&gt; // ...&gt; // 等等，这个$li是什么意思?&gt; dispatch($li);&gt;&#125;&gt; &gt; 友好的: 1234567891011&gt;$locations = ['Austin', 'New York', 'San Francisco'];&gt;&gt;foreach ($locations as $location) &#123;&gt; doStuff();&gt; doSomeOtherStuff();&gt; // ...&gt; // ...&gt; // ...&gt; dispatch($location);&gt;&#125;&gt; 别添加没必要的上下文&gt; 如果你的类或对象的名字已经传达了一些信息，那么请别在变量名中重复。 不友好的 123456789&gt;class Car&gt;&#123;&gt; public $carMake;&gt; public $carModel;&gt; public $carColor;&gt;&gt; //...&gt;&#125;&gt; &gt; 友好的 123456789&gt;class Car&gt;&#123;&gt; public $make;&gt; public $model;&gt; public $color;&gt;&gt; //...&gt;&#125;&gt; 用参数默认值代替短路运算或条件运算 不友好的 这里不太合理，因为变量$breweryName有可能是NULL。 12345&gt;function createMicrobrewery($breweryName = 'Hipster Brew Co.'): void&gt;&#123;&gt; // ...&gt;&#125;&gt; &gt; 不至于那么糟糕的 这种写法要比上一版稍微好理解一些，但是如果能控制变量值获取会更好。 123456&gt;function createMicrobrewery($name = null): void&gt;&#123;&gt; $breweryName = $name ?: 'Hipster Brew Co.';&gt; // ...&gt;&#125;&gt; &gt; 友好的 如果你仅支持 PHP 7+，那么你可以使用类型约束并且保证$http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration变量不会为NULL。 12345&gt;function createMicrobrewery(string $breweryName = 'Hipster Brew Co.'): void&gt;&#123;&gt; // ...&gt;&#125;&gt; 函数 函数参数应该控制在两个以下 &gt; 限制函数的参数对于在对函数做测试来说相当重要。有超过三个可选的参数会给你的测试工作量带来倍速增长。 最理想的情况是没有参数。1-2个参数也还凑合，但是三个参数就应该避免了。参数越多，我们需要维护的就越多。通常，如果你的函&gt;数有超过2个的参数，那么你的这个函数需要处理的事情就太多了。如果的确需要这么多参数，那么在大多数情况下， 用一个对象来处理可能会更合适。 不友好的: 12345&gt;function createMenu(string $title, string $body, string $buttonText, bool $cancellable): void&gt;&#123;&gt; // ...&gt;&#125;&gt; &gt; 友好的: 12345678910111213141516171819&gt;class MenuConfig&gt;&#123;&gt; public $title;&gt; public $body;&gt; public $buttonText;&gt; public $cancellable = false;&gt;&#125;&gt;&gt;$config = new MenuConfig();&gt;$config-&gt;title = 'Foo';&gt;$config-&gt;body = 'Bar';&gt;$config-&gt;buttonText = 'Baz';&gt;$config-&gt;cancellable = true;&gt;&gt;function createMenu(MenuConfig $config): void&gt;&#123;&gt; // ...&gt;&#125;&gt; 一个函数只做一件事情 在软件工程行业，这是最重要的准则。当函数所处理的事情超过一件，他就会变得难以实现，测试和理解。当你能让一个函数仅仅负责一个事情，他们就会变得容易重构并且理解起来越清晰。光是执行这样一条原则就能让你成为开发者中的佼佼者了。 不友好的:12345678910&gt;function emailClients(array $clients): void&gt;&#123;&gt; foreach ($clients as $client) &#123;&gt; $clientRecord = $db-&gt;find($client);&gt; if ($clientRecord-&gt;isActive()) &#123;&gt; email($client);&gt; &#125;&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 123456789101112131415161718&gt;function emailClients(array $clients): void&gt;&#123;&gt; $activeClients = activeClients($clients);&gt; array_walk($activeClients, 'email');&gt;&#125;&gt;&gt;function activeClients(array $clients): array&gt;&#123;&gt; return array_filter($clients, 'isClientActive');&gt;&#125;&gt;&gt;function isClientActive(int $client): bool&gt;&#123;&gt; $clientRecord = $db-&gt;find($client);&gt;&gt; return $clientRecord-&gt;isActive();&gt;&#125;&gt; 函数名应该说到做到 不友好的: 1234567891011121314&gt;class Email&gt;&#123;&gt; //...&gt;&gt; public function handle(): void&gt; &#123;&gt; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);&gt; &#125;&gt;&#125;&gt;&gt;$message = new Email(...);&gt;// 这是什么？这个`handle`方法是什么？我们现在应该写入到一个文件吗？&gt;$message-&gt;handle();&gt; &gt; 友好的: 1234567891011121314&gt;class Email&gt;&#123;&gt; //...&gt;&gt; public function send(): void&gt; &#123;&gt; mail($this-&gt;to, $this-&gt;subject, $this-&gt;body);&gt; &#125;&gt;&#125;&gt;&gt;$message = new Email(...);&gt;// 清晰并且显而易见&gt;$message-&gt;send();&gt; 函数应该只有一层抽象 当你的函数有超过一层的抽象时便意味着这个函数做了太多事情。解耦这个函数致使其变得可重用和更易测试。 不友好的: 123456789101112131415161718192021222324&gt;function parseBetterJSAlternative(string $code): void&gt;&#123;&gt; $regexes = [&gt; // ...&gt; ];&gt;&gt; $statements = explode(' ', $code);&gt; $tokens = [];&gt; foreach ($regexes as $regex) &#123;&gt; foreach ($statements as $statement) &#123;&gt; // ...&gt; &#125;&gt; &#125;&gt;&gt; $ast = [];&gt; foreach ($tokens as $token) &#123;&gt; // lex...&gt; &#125;&gt;&gt; foreach ($ast as $node) &#123;&gt; // parse...&gt; &#125;&gt;&#125;&gt; &gt; 同样不太友好: 我们已经从函数中拆分除了一些东西出来，但是parseBetterJSAlternative()这个函数还是太复杂以至于难以测试。 123456789101112131415161718192021222324252627282930313233343536&gt;function tokenize(string $code): array&gt;&#123;&gt; $regexes = [&gt; // ...&gt; ];&gt;&gt; $statements = explode(' ', $code);&gt; $tokens = [];&gt; foreach ($regexes as $regex) &#123;&gt; foreach ($statements as $statement) &#123;&gt; $tokens[] = /* ... */;&gt; &#125;&gt; &#125;&gt;&gt; return $tokens;&gt;&#125;&gt;&gt;function lexer(array $tokens): array&gt;&#123;&gt; $ast = [];&gt; foreach ($tokens as $token) &#123;&gt; $ast[] = /* ... */;&gt; &#125;&gt;&gt; return $ast;&gt;&#125;&gt;&gt;function parseBetterJSAlternative(string $code): void&gt;&#123;&gt; $tokens = tokenize($code);&gt; $ast = lexer($tokens);&gt; foreach ($ast as $node) &#123;&gt; // parse...&gt; &#125;&gt;&#125;&gt; &gt; 友好的 最优解就是把parseBetterJSAlternative()函数依赖的东西分离出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&gt;class Tokenizer&gt;&#123;&gt; public function tokenize(string $code): array&gt; &#123;&gt; $regexes = [&gt; // ...&gt; ];&gt;&gt; $statements = explode(' ', $code);&gt; $tokens = [];&gt; foreach ($regexes as $regex) &#123;&gt; foreach ($statements as $statement) &#123;&gt; $tokens[] = /* ... */;&gt; &#125;&gt; &#125;&gt;&gt; return $tokens;&gt; &#125;&gt;&#125;&gt;&gt;class Lexer&gt;&#123;&gt; public function lexify(array $tokens): array&gt; &#123;&gt; $ast = [];&gt; foreach ($tokens as $token) &#123;&gt; $ast[] = /* ... */;&gt; &#125;&gt;&gt; return $ast;&gt; &#125;&gt;&#125;&gt;&gt;class BetterJSAlternative&gt;&#123;&gt; private $tokenizer;&gt; private $lexer;&gt;&gt; public function __construct(Tokenizer $tokenizer, Lexer $lexer)&gt; &#123;&gt; $this-&gt;tokenizer = $tokenizer;&gt; $this-&gt;lexer = $lexer;&gt; &#125;&gt;&gt; public function parse(string $code): void&gt; &#123;&gt; $tokens = $this-&gt;tokenizer-&gt;tokenize($code);&gt; $ast = $this-&gt;lexer-&gt;lexify($tokens);&gt; foreach ($ast as $node) &#123;&gt; // parse...&gt; &#125;&gt; &#125;&gt;&#125;&gt; 不要在函数中带入flag相关的参数 当你使用flag时便意味着你的函数做了超过一件事情。前面我们也提到了，函数应该只做一件事情。如果你的代码取决于一个boolean，那么还是把这些内容拆分出来吧。 不友好的 123456789&gt;function createFile(string $name, bool $temp = false): void&gt;&#123;&gt; if ($temp) &#123;&gt; touch('./temp/'.$name);&gt; &#125; else &#123;&gt; touch($name);&gt; &#125;&gt;&#125;&gt; &gt; 友好的 12345678910&gt;function createFile(string $name): void&gt;&#123;&gt; touch($name);&gt;&#125;&gt;&gt;function createTempFile(string $name): void&gt;&#123;&gt; touch('./temp/'.$name);&gt;&#125;&gt; 避免函数带来的副作用 当函数有数据的输入和输出时可能会产生副作用。这个副作用可能被写入一个文件，修改一些全局变量，或者意外的把你的钱转给一个陌生人。 此刻，你可能有时候会需要这些副作用。正如前面所说，你可能需要写入到一个文件中。你需要注意的是把这些你所做的东西在你的掌控之下。别让某些个别函数或者类写入了一个特别的文件。对于所有的都应该一视同仁。有且仅有一个结果。 重要的是要避免那些譬如共享无结构的对象，使用可以写入任何类型的可变数据，不对副作用进行集中处理等常见的陷阱。如果你可以做到，你将会比大多数程序猿更加轻松。 不友好的 123456789101112131415&gt;// 全局变量被下面的函数引用了。&gt;// 如果我们在另外一个函数中使用了这个`$name`变量，那么可能会变成一个数组或者程序被打断。&gt;$name = 'Ryan McDermott';&gt;&gt;function splitIntoFirstAndLastName(): void&gt;&#123;&gt; global $name;&gt;&gt; $name = explode(' ', $name);&gt;&#125;&gt;&gt;splitIntoFirstAndLastName();&gt;&gt;var_dump($name); // ['Ryan', 'McDermott'];&gt; &gt; 友好的 1234567891011&gt;function splitIntoFirstAndLastName(string $name): array&gt;&#123;&gt; return explode(' ', $name);&gt;&#125;&gt;&gt;$name = 'Ryan McDermott';&gt;$newName = splitIntoFirstAndLastName($name);&gt;&gt;var_dump($name); // 'Ryan McDermott';&gt;var_dump($newName); // ['Ryan', 'McDermott'];&gt; 避免写全局方法 在大多数语言中，全局变量被污染都是一个不太好的实践，因为当你引入另外的包时会起冲突并且使用你的API的人知道抛出了一个异常才明白。我们假设一个简单的例子：如果你想要一个配置数组。你可能会写一个类似于config()的全局的函数，但是在引入其他包并在其他地方尝试做同样的事情时会起冲突。 不友好的 1234567&gt;function config(): array&gt;&#123;&gt; return [&gt; 'foo' =&gt; 'bar',&gt; ]&gt;&#125;&gt; &gt; 不友好的 123456789101112131415&gt;class Configuration&gt;&#123;&gt; private $configuration = [];&gt;&gt; public function __construct(array $configuration)&gt; &#123;&gt; $this-&gt;configuration = $configuration;&gt; &#125;&gt;&gt; public function get(string $key): ?string&gt; &#123;&gt; return isset($this-&gt;configuration[$key]) ? $this-&gt;configuration[$key] : null;&gt; &#125;&gt;&#125;&gt; &gt; 通过创建Configuration类的实例来引入配置 1234&gt;$configuration = new Configuration([&gt; 'foo' =&gt; 'bar',&gt;]);&gt; &gt; 至此，你就可以是在你的项目中使用这个配置了。 避免使用单例模式 单例模式是一种反模式。为什么不建议使用: 他们通常使用一个全局实例，为什么这么糟糕？因为你隐藏了依赖关系在你的项目的代码中，而不是通过接口暴露出来。你应该有意识的去避免那些全局的东西。 他们违背了单一职责原则：他们会自己控制自己的生命周期。 这种模式会自然而然的使代码耦合在一起。这会让他们在测试中，很多情况下都理所当然的不一致。 他们持续在整个项目的生命周期中。另外一个严重的打击是当你需要排序测试的时候，在单元测试中这会是一个不小的麻烦。为什么？因为每个单元测试都应该依赖于另外一个。 不友好的 1234567891011121314151617181920212223&gt;class DBConnection&gt;&#123;&gt; private static $instance;&gt;&gt; private function __construct(string $dsn)&gt; &#123;&gt; // ...&gt; &#125;&gt;&gt; public static function getInstance(): DBConnection&gt; &#123;&gt; if (self::$instance === null) &#123;&gt; self::$instance = new self();&gt; &#125;&gt;&gt; return self::$instance;&gt; &#125;&gt;&gt; // ...&gt;&#125;&gt;&gt;$singleton = DBConnection::getInstance();&gt; &gt; 友好的 12345678910&gt;class DBConnection&gt;&#123;&gt; public function __construct(string $dsn)&gt; &#123;&gt; // ...&gt; &#125;&gt;&gt; // ...&gt;&#125;&gt; &gt; 使用DSN配置来创建一个DBConnection类的单例。 12&gt;$connection = new DBConnection($dsn);&gt; &gt; 此时，在你的项目中必须使用DBConnection的单例。 对条件判断进行包装 不友好的 1234&gt;if ($article-&gt;state === 'published') &#123;&gt; // ...&gt;&#125;&gt; &gt; 友好的 1234&gt;if ($article-&gt;isPublished()) &#123;&gt; // ...&gt;&#125;&gt; 避免对条件取反 不友好的 12345678910&gt;function isDOMNodeNotPresent(\\DOMNode $node): bool&gt;&#123;&gt; // ...&gt;&#125;&gt;&gt;if (!isDOMNodeNotPresent($node))&gt;&#123;&gt; // ...&gt;&#125;&gt; &gt; 友好的 123456789&gt;function isDOMNodePresent(\\DOMNode $node): bool&gt;&#123;&gt; // ...&gt;&#125;&gt;&gt;if (isDOMNodePresent($node)) &#123;&gt; // ...&gt;&#125;&gt; 避免太多的条件嵌套 这似乎是一个不可能的任务。很多人的脑海中可能会在第一时间萦绕“如果没有if条件我还能做什么呢？”。答案就是，在大多数情况下，你可以使用多态去处理这个难题。此外，可能有人又会说了，“即使多态可以做到，但是我们为什么要这么做呢？”，对此我们的解释是，一个函数应该只做一件事情，这也正是我们在前面所提到的让代码更加整洁的原则。当你的函数中使用了太多的if条件时，便意味着你的函数做了超过一件事情。牢记：要专一。 不友好的: 1234567891011121314151617&gt;class Airplane&gt;&#123;&gt; // ...&gt;&gt; public function getCruisingAltitude(): int&gt; &#123;&gt; switch ($this-&gt;type) &#123;&gt; case '777':&gt; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();&gt; case 'Air Force One':&gt; return $this-&gt;getMaxAltitude();&gt; case 'Cessna':&gt; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();&gt; &#125;&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 12345678910111213141516171819202122232425262728293031323334353637&gt;interface Airplane&gt;&#123;&gt; // ...&gt;&gt; public function getCruisingAltitude(): int;&gt;&#125;&gt;&gt;class Boeing777 implements Airplane&gt;&#123;&gt; // ...&gt;&gt; public function getCruisingAltitude(): int&gt; &#123;&gt; return $this-&gt;getMaxAltitude() - $this-&gt;getPassengerCount();&gt; &#125;&gt;&#125;&gt;&gt;class AirForceOne implements Airplane&gt;&#123;&gt; // ...&gt;&gt; public function getCruisingAltitude(): int&gt; &#123;&gt; return $this-&gt;getMaxAltitude();&gt; &#125;&gt;&#125;&gt;&gt;class Cessna implements Airplane&gt;&#123;&gt; // ...&gt;&gt; public function getCruisingAltitude(): int&gt; &#123;&gt; return $this-&gt;getMaxAltitude() - $this-&gt;getFuelExpenditure();&gt; &#125;&gt;&#125;&gt; 避免类型检测 (part 1) PHP是一门弱类型语言，这意味着你的函数可以使用任何类型的参数。他在给予你无限的自由的同时又让你困扰，因为有有时候你需要做类型检测。这里有很多方式去避免这种事情，第一种方式就是统一API。 不友好的： 123456789&gt;function travelToTexas($vehicle): void&gt;&#123;&gt; if ($vehicle instanceof Bicycle) &#123;&gt; $vehicle-&gt;pedalTo(new Location('texas'));&gt; &#125; elseif ($vehicle instanceof Car) &#123;&gt; $vehicle-&gt;driveTo(new Location('texas'));&gt; &#125;&gt;&#125;&gt; &gt; 友好的： 12345&gt;function travelToTexas(Traveler $vehicle): void&gt;&#123;&gt; $vehicle-&gt;travelTo(new Location('texas'));&gt;&#125;&gt; 避免类型检测 (part 2) 如果你正使用诸如字符串、整型和数组等基本类型，且要求版本是PHP 7+，不能使用多态，需要类型检测，那你应当考虑类型声明或者严格模式。它提供了基于标准PHP语法的静态类型。手动检查类型的问题是做好了需要好多的废话，好像为了安全就可以不顾损失可读性。保持你的PHP代码整洁，写好测试，保持良好的回顾代码的习惯。否则的话，那就还是用PHP严格类型声明和严格模式来确保安全吧。 不友好的: 123456789&gt;function combine($val1, $val2): int&gt;&#123;&gt; if (!is_numeric($val1) || !is_numeric($val2)) &#123;&gt; throw new \\Exception('Must be of type Number');&gt; &#125;&gt;&gt; return $val1 + $val2;&gt;&#125;&gt; &gt; 友好的: 12345&gt;function combine(int $val1, int $val2): int&gt;&#123;&gt; return $val1 + $val2;&gt;&#125;&gt; 移除那些没有使用的代码 没有再使用的代码就好比重复代码一样糟糕。在你的代码库中完全没有必要保留。如果确定不再使用，那就把它删掉吧！如果有一天你要使用，你也可以在你的版本记录中找到它。 不友好的: 12345678910111213&gt;function oldRequestModule(string $url): void&gt;&#123;&gt; // ...&gt;&#125;&gt;&gt;function newRequestModule(string $url): void&gt;&#123;&gt; // ...&gt;&#125;&gt;&gt;$request = newRequestModule($requestUrl);&gt;inventoryTracker('apples', $request, 'www.inventory-awesome.io');&gt; &gt; 友好的: 12345678&gt;function requestModule(string $url): void&gt;&#123;&gt; // ...&gt;&#125;&gt;&gt;$request = requestModule($requestUrl);&gt;inventoryTracker('apples', $request, 'www.inventory-awesome.io');&gt; 对象和数据结构 使用对象封装 在PHP中你可以设置public，protected，和private关键词来修饰你的方法。当你使用它们，你就可以在一个对象中控制这些属性的修改权限了。 当你想要对对象的属性进行除了“获取”之外的操作时，你不必再去浏览并在代码库中修改权限。 当你要做一些修改属性的操作时，你更易于在代码中做逻辑验证。 封装内部表示。 当你在做获取和设置属性的操作时，更易于添加log或error的操作。 当其他class继承了这个基类，你可以重写默认的方法。 你可以为一个服务延迟的去获取这个对象的属性值。 不太友好的: 12345678910&gt;class BankAccount&gt;&#123;&gt; public $balance = 1000;&gt;&#125;&gt;&gt;$bankAccount = new BankAccount();&gt;&gt;// Buy shoes...&gt;$bankAccount-&gt;balance -= 100;&gt; &gt; 友好的: 12345678910111213141516171819202122232425262728293031323334353637&gt;class BankAccount&gt;&#123;&gt; private $balance;&gt;&gt; public function __construct(int $balance = 1000)&gt; &#123;&gt; $this-&gt;balance = $balance;&gt; &#125;&gt;&gt; public function withdraw(int $amount): void&gt; &#123;&gt; if ($amount &gt; $this-&gt;balance) &#123;&gt; throw new \\Exception('Amount greater than available balance.');&gt; &#125;&gt;&gt; $this-&gt;balance -= $amount;&gt; &#125;&gt;&gt; public function deposit(int $amount): void&gt; &#123;&gt; $this-&gt;balance += $amount;&gt; &#125;&gt;&gt; public function getBalance(): int&gt; &#123;&gt; return $this-&gt;balance;&gt; &#125;&gt;&#125;&gt;&gt;$bankAccount = new BankAccount();&gt;&gt;// Buy shoes...&gt;$bankAccount-&gt;withdraw($shoesPrice);&gt;&gt;// Get balance&gt;$balance = $bankAccount-&gt;getBalance();&gt; 在对象的属性上可以使用private/protected限定 public修饰的方法和属性同上来说被修改是比较危险的，因为一些外部的代码可以轻易的依赖于他们并且你没办法控制哪些代码依赖于他们。对于所有用户的类来说，在类中可以修改是相当危险的。 protected修饰器和public同样危险，因为他们在继承链中同样可以操作。二者的区别仅限于权限机制，并且封装保持不变。对于所有子类来说，在类中修改也是相当危险的。 private修饰符保证了代码只有在自己类的内部修改才是危险的。 因此，当你在需要对外部的类设置权限时使用private修饰符去取代public/protected吧。 如果需要了解更多信息你可以读Fabien Potencier写的这篇文章 不太友好的: 12345678910111213&gt;class Employee&gt;&#123;&gt; public $name;&gt;&gt; public function __construct(string $name)&gt; &#123;&gt; $this-&gt;name = $name;&gt; &#125;&gt;&#125;&gt;&gt;$employee = new Employee('John Doe');&gt;echo 'Employee name: '.$employee-&gt;name; // Employee name: John Doe&gt; &gt; 友好的: 123456789101112131415161718&gt;class Employee&gt;&#123;&gt; private $name;&gt;&gt; public function __construct(string $name)&gt; &#123;&gt; $this-&gt;name = $name;&gt; &#125;&gt;&gt; public function getName(): string&gt; &#123;&gt; return $this-&gt;name;&gt; &#125;&gt;&#125;&gt;&gt;$employee = new Employee('John Doe');&gt;echo 'Employee name: '.$employee-&gt;getName(); // Employee name: John Doe&gt; 组合优于继承 正如the Gang of Four在著名的Design Patterns中所说，你应该尽可能的使用组合而不是继承。不管是使用组合还是继承都有很多的优点。最重要的一个准则在于当你本能的想要使用继承时，不妨思考一下组合是否能让你的问题解决的更加优雅。在某些时候确实如此。 你可能会这么问了，“那到底什么时候我应该使用继承呢？”这完全取决你你手头上的问题，下面正好有一些继承优于组合的例子： 你的继承表达了“是一个”而不是“有一个”的关系(Human-&gt;Animal vs. User-&gt;UserDetails)。 你可能会重复的使用基类的代码(Humans can move like all animals)。 你渴望在修改代码的时候通过基类来统一调度(Change the caloric expenditure of all animals when they move)。 不友好的: 1234567891011121314151617181920212223242526272829303132&gt;class Employee&gt;&#123;&gt; private $name;&gt; private $email;&gt;&gt; public function __construct(string $name, string $email)&gt; &#123;&gt; $this-&gt;name = $name;&gt; $this-&gt;email = $email;&gt; &#125;&gt;&gt; // ...&gt;&#125;&gt;&gt;// 这里不太合理的原因在于并非所有的职员都有`tax`这个特征。&gt;&gt;class EmployeeTaxData extends Employee&gt;&#123;&gt; private $ssn;&gt; private $salary;&gt;&gt; public function __construct(string $name, string $email, string $ssn, string $salary)&gt; &#123;&gt; parent::__construct($name, $email);&gt;&gt; $this-&gt;ssn = $ssn;&gt; $this-&gt;salary = $salary;&gt; &#125;&gt;&gt; // ...&gt;&#125;&gt; &gt; 友好的: 12345678910111213141516171819202122232425262728293031323334&gt;class EmployeeTaxData&gt;&#123;&gt; private $ssn;&gt; private $salary;&gt;&gt; public function __construct(string $ssn, string $salary)&gt; &#123;&gt; $this-&gt;ssn = $ssn;&gt; $this-&gt;salary = $salary;&gt; &#125;&gt;&gt; // ...&gt;&#125;&gt;&gt;class Employee&gt;&#123;&gt; private $name;&gt; private $email;&gt; private $taxData;&gt;&gt; public function __construct(string $name, string $email)&gt; &#123;&gt; $this-&gt;name = $name;&gt; $this-&gt;email = $email;&gt; &#125;&gt;&gt; public function setTaxData(string $ssn, string $salary)&gt; &#123;&gt; $this-&gt;taxData = new EmployeeTaxData($ssn, $salary);&gt; &#125;&gt;&gt; // ...&gt;&#125;&gt; 避免链式调用(连贯接口) 在使用一些链式方法时，这种连贯接口可以不断地指向当前对象让我们的代码显得更加清晰可读。 通常情况下，我们在构建对象时都可以利用他的上下文这一特征，因为这种模式可以减少代码的冗余，不过在PHPUnit Mock Builder或者Doctrine Query Builder所提及的，有时候这种方式会带来一些麻烦： 破坏封装 破坏设计 难以测试 可能会难以阅读 如果需要了解更多信息你可以读Marco Pivetta写的这篇文章 友好的: 123456789101112131415161718192021222324252627282930313233343536373839404142&gt;class Car&gt;&#123;&gt; private $make = 'Honda';&gt; private $model = 'Accord';&gt; private $color = 'white';&gt;&gt; public function setMake(string $make): self&gt; &#123;&gt; $this-&gt;make = $make;&gt;&gt; // NOTE: Returning this for chaining&gt; return $this;&gt; &#125;&gt;&gt; public function setModel(string $model): self&gt; &#123;&gt; $this-&gt;model = $model;&gt;&gt; // NOTE: Returning this for chaining&gt; return $this;&gt; &#125;&gt;&gt; public function setColor(string $color): self&gt; &#123;&gt; $this-&gt;color = $color;&gt;&gt; // NOTE: Returning this for chaining&gt; return $this;&gt; &#125;&gt;&gt; public function dump(): void&gt; &#123;&gt; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);&gt; &#125;&gt;&#125;&gt;&gt;$car = (new Car())&gt; -&gt;setColor('pink')&gt; -&gt;setMake('Ford')&gt; -&gt;setModel('F-150')&gt; -&gt;dump();&gt; &gt; 不友好的: 123456789101112131415161718192021222324252627282930313233&gt;class Car&gt;&#123;&gt; private $make = 'Honda';&gt; private $model = 'Accord';&gt; private $color = 'white';&gt;&gt; public function setMake(string $make): void&gt; &#123;&gt; $this-&gt;make = $make;&gt; &#125;&gt;&gt; public function setModel(string $model): void&gt; &#123;&gt; $this-&gt;model = $model;&gt; &#125;&gt;&gt; public function setColor(string $color): void&gt; &#123;&gt; $this-&gt;color = $color;&gt; &#125;&gt;&gt; public function dump(): void&gt; &#123;&gt; var_dump($this-&gt;make, $this-&gt;model, $this-&gt;color);&gt; &#125;&gt;&#125;&gt;&gt;$car = new Car();&gt;$car-&gt;setColor('pink');&gt;$car-&gt;setMake('Ford');&gt;$car-&gt;setModel('F-150');&gt;$car-&gt;dump();&gt; SOLID SOLID最开始是由Robert Martin提出的五个准则，并最后由Michael Feathers命名的简写，这五个是在面对对象设计中的五个基本原则。 S: 职责单一原则 (SRP) O: 开闭原则 (OCP) L: 里氏替换原则 (LSP) I: 接口隔离原则 (ISP) D: 依赖反转原则 (DIP) 职责单一原则 (SRP) 正如Clean Code所述，“修改类应该只有一个理由”。我们总是喜欢在类中写入太多的方法，就像你在飞机上塞满你的行李箱。在这种情况下你的类没有高内聚的概念并且留下了很多可以修改的理由。尽可能的减少你需要去修改类的时间是非常重要的。如果在你的单个类中有太多的方法并且你经常修改的话，那么如果其他代码库中有引入这样的模块的话会非常难以理解。 不友好的: 12345678910111213141516171819202122&gt;class UserSettings&gt;&#123;&gt; private $user;&gt;&gt; public function __construct(User $user)&gt; &#123;&gt; $this-&gt;user = $user;&gt; &#125;&gt;&gt; public function changeSettings(array $settings): void&gt; &#123;&gt; if ($this-&gt;verifyCredentials()) &#123;&gt; // ...&gt; &#125;&gt; &#125;&gt;&gt; private function verifyCredentials(): bool&gt; &#123;&gt; // ...&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 12345678910111213141516171819202122232425262728293031323334&gt;class UserAuth&gt;&#123;&gt; private $user;&gt;&gt; public function __construct(User $user)&gt; &#123;&gt; $this-&gt;user = $user;&gt; &#125;&gt;&gt; public function verifyCredentials(): bool&gt; &#123;&gt; // ...&gt; &#125;&gt;&#125;&gt;&gt;class UserSettings&gt;&#123;&gt; private $user;&gt; private $auth;&gt;&gt; public function __construct(User $user)&gt; &#123;&gt; $this-&gt;user = $user;&gt; $this-&gt;auth = new UserAuth($user);&gt; &#125;&gt;&gt; public function changeSettings(array $settings): void&gt; &#123;&gt; if ($this-&gt;auth-&gt;verifyCredentials()) &#123;&gt; // ...&gt; &#125;&gt; &#125;&gt;&#125;&gt; 开闭原则 (OCP) 正如Bertrand Meyer所说，“软件开发应该对扩展开发，对修改关闭。”这是什么意思呢？这个原则的意思大概就是说你应该允许其他人在不修改已经存在的功能的情况下去增加新功能。 不友好的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt;abstract class Adapter&gt;&#123;&gt; protected $name;&gt;&gt; public function getName(): string&gt; &#123;&gt; return $this-&gt;name;&gt; &#125;&gt;&#125;&gt;&gt;class AjaxAdapter extends Adapter&gt;&#123;&gt; public function __construct()&gt; &#123;&gt; parent::__construct();&gt;&gt; $this-&gt;name = 'ajaxAdapter';&gt; &#125;&gt;&#125;&gt;&gt;class NodeAdapter extends Adapter&gt;&#123;&gt; public function __construct()&gt; &#123;&gt; parent::__construct();&gt;&gt; $this-&gt;name = 'nodeAdapter';&gt; &#125;&gt;&#125;&gt;&gt;class HttpRequester&gt;&#123;&gt; private $adapter;&gt;&gt; public function __construct(Adapter $adapter)&gt; &#123;&gt; $this-&gt;adapter = $adapter;&gt; &#125;&gt;&gt; public function fetch(string $url): Promise&gt; &#123;&gt; $adapterName = $this-&gt;adapter-&gt;getName();&gt;&gt; if ($adapterName === 'ajaxAdapter') &#123;&gt; return $this-&gt;makeAjaxCall($url);&gt; &#125; elseif ($adapterName === 'httpNodeAdapter') &#123;&gt; return $this-&gt;makeHttpCall($url);&gt; &#125;&gt; &#125;&gt;&gt; private function makeAjaxCall(string $url): Promise&gt; &#123;&gt; // request and return promise&gt; &#125;&gt;&gt; private function makeHttpCall(string $url): Promise&gt; &#123;&gt; // request and return promise&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 123456789101112131415161718192021222324252627282930313233343536&gt;interface Adapter&gt;&#123;&gt; public function request(string $url): Promise;&gt;&#125;&gt;&gt;class AjaxAdapter implements Adapter&gt;&#123;&gt; public function request(string $url): Promise&gt; &#123;&gt; // request and return promise&gt; &#125;&gt;&#125;&gt;&gt;class NodeAdapter implements Adapter&gt;&#123;&gt; public function request(string $url): Promise&gt; &#123;&gt; // request and return promise&gt; &#125;&gt;&#125;&gt;&gt;class HttpRequester&gt;&#123;&gt; private $adapter;&gt;&gt; public function __construct(Adapter $adapter)&gt; &#123;&gt; $this-&gt;adapter = $adapter;&gt; &#125;&gt;&gt; public function fetch(string $url): Promise&gt; &#123;&gt; return $this-&gt;adapter-&gt;request($url);&gt; &#125;&gt;&#125;&gt; 里氏替换原则 (LSP) 这本身是一个非常简单的原则却起了一个不太容易理解的名字。这个原则通常的定义是“如果S是T的一个子类，那么对象T可以在没有任何警告的情况下被他的子类替换（例如：对象S可能代替对象T）一些更合适的属性。”好像更难理解了。 最好的解释就是说如果你有一个父类和子类，那么你的父类和子类可以在原来的基础上任意交换。这个可能还是难以理解，我们举一个正方形-长方形的例子吧。在数学中，一个矩形属于长方形，但是如果在你的模型中通过继承使用了“is-a”的关系就不对了。 不友好的: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt;class Rectangle&gt;&#123;&gt; protected $width = 0;&gt; protected $height = 0;&gt;&gt; public function render(int $area): void&gt; &#123;&gt; // ...&gt; &#125;&gt;&gt; public function setWidth(int $width): void&gt; &#123;&gt; $this-&gt;width = $width;&gt; &#125;&gt;&gt; public function setHeight(int $height): void&gt; &#123;&gt; $this-&gt;height = $height;&gt; &#125;&gt;&gt; public function getArea(): int&gt; &#123;&gt; return $this-&gt;width * $this-&gt;height;&gt; &#125;&gt;&#125;&gt;&gt;class Square extends Rectangle&gt;&#123;&gt; public function setWidth(int $width): void&gt; &#123;&gt; $this-&gt;width = $this-&gt;height = $width;&gt; &#125;&gt;&gt; public function setHeight(int $height): void&gt; &#123;&gt; $this-&gt;width = $this-&gt;height = $height;&gt; &#125;&gt;&#125;&gt;&gt;function renderLargeRectangles(array $rectangles): void&gt;&#123;&gt; foreach ($rectangles as $rectangle) &#123;&gt; $rectangle-&gt;setWidth(4);&gt; $rectangle-&gt;setHeight(5);&gt; $area = $rectangle-&gt;getArea(); // BAD: Will return 25 for Square. Should be 20.&gt; $rectangle-&gt;render($area);&gt; &#125;&gt;&#125;&gt;&gt;$rectangles = [new Rectangle(), new Rectangle(), new Square()];&gt;renderLargeRectangles($rectangles);&gt; &gt; 友好的: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&gt;abstract class Shape&gt;&#123;&gt; protected $width = 0;&gt; protected $height = 0;&gt;&gt; abstract public function getArea(): int;&gt;&gt; public function render(int $area): void&gt; &#123;&gt; // ...&gt; &#125;&gt;&#125;&gt;&gt;class Rectangle extends Shape&gt;&#123;&gt; public function setWidth(int $width): void&gt; &#123;&gt; $this-&gt;width = $width;&gt; &#125;&gt;&gt; public function setHeight(int $height): void&gt; &#123;&gt; $this-&gt;height = $height;&gt; &#125;&gt;&gt; public function getArea(): int&gt; &#123;&gt; return $this-&gt;width * $this-&gt;height;&gt; &#125;&gt;&#125;&gt;&gt;class Square extends Shape&gt;&#123;&gt; private $length = 0;&gt;&gt; public function setLength(int $length): void&gt; &#123;&gt; $this-&gt;length = $length;&gt; &#125;&gt;&gt; public function getArea(): int&gt; &#123;&gt; return pow($this-&gt;length, 2);&gt; &#125;&gt;&#125;&gt;&gt;&gt;function renderLargeRectangles(array $rectangles): void&gt;&#123;&gt; foreach ($rectangles as $rectangle) &#123;&gt; if ($rectangle instanceof Square) &#123;&gt; $rectangle-&gt;setLength(5);&gt; &#125; elseif ($rectangle instanceof Rectangle) &#123;&gt; $rectangle-&gt;setWidth(4);&gt; $rectangle-&gt;setHeight(5);&gt; &#125;&gt;&gt; $area = $rectangle-&gt;getArea();&gt; $rectangle-&gt;render($area);&gt; &#125;&gt;&#125;&gt;&gt;$shapes = [new Rectangle(), new Rectangle(), new Square()];&gt;renderLargeRectangles($shapes);&gt; 接口隔离原则 (ISP) ISP的意思就是说“使用者不应该强制使用它不需要的接口”。 当一个类需要大量的设置是一个不错的例子去解释这个原则。为了方便去调用这个接口需要做大量的设置，但是大多数情况下是不需要的。强制让他们使用这些设置会让整个接口显得臃肿。 不友好的: 123456789101112131415161718192021222324252627282930313233&gt;interface Employee&gt;&#123;&gt; public function work(): void;&gt;&gt; public function eat(): void;&gt;&#125;&gt;&gt;class Human implements Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; // ....working&gt; &#125;&gt;&gt; public function eat(): void&gt; &#123;&gt; // ...... eating in lunch break&gt; &#125;&gt;&#125;&gt;&gt;class Robot implements Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; //.... working much more&gt; &#125;&gt;&gt; public function eat(): void&gt; &#123;&gt; //.... robot can't eat, but it must implement this method&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 并非每一个工人都是职员，但是每一个职员都是工人。 123456789101112131415161718192021222324252627282930313233343536&gt;interface Workable&gt;&#123;&gt; public function work(): void;&gt;&#125;&gt;&gt;interface Feedable&gt;&#123;&gt; public function eat(): void;&gt;&#125;&gt;&gt;interface Employee extends Feedable, Workable&gt;&#123;&gt;&#125;&gt;&gt;class Human implements Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; // ....working&gt; &#125;&gt;&gt; public function eat(): void&gt; &#123;&gt; //.... eating in lunch break&gt; &#125;&gt;&#125;&gt;&gt;// robot can only work&gt;class Robot implements Workable&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; // ....working&gt; &#125;&gt;&#125;&gt; &gt; 依赖反转原则 (DIP) 这个原则有两个需要注意的地方： 高阶模块不能依赖于低阶模块。他们都应该依赖于抽象。 抽象不应该依赖于实现，实现应该依赖于抽象。 第一点可能有点难以理解，但是如果你有使用过像Symfony的PHP框架，你应该有见到过依赖注入这样的原则的实现。尽管他们是不一样的概念，DIP让高阶模块从我们所知道的低阶模块中分离出去。可以通过DI这种方式实现。一个巨大的好处在于它解耦了不同的模块。耦合是一个非常不好的开发模式，因为它会让你的代码难以重构。 不友好的: 12345678910111213141516171819202122232425262728293031&gt;class Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; // ....working&gt; &#125;&gt;&#125;&gt;&gt;class Robot extends Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; //.... working much more&gt; &#125;&gt;&#125;&gt;&gt;class Manager&gt;&#123;&gt; private $employee;&gt;&gt; public function __construct(Employee $employee)&gt; &#123;&gt; $this-&gt;employee = $employee;&gt; &#125;&gt;&gt; public function manage(): void&gt; &#123;&gt; $this-&gt;employee-&gt;work();&gt; &#125;&gt;&#125;&gt; &gt; 友好的 123456789101112131415161718192021222324252627282930313233343536&gt;interface Employee&gt;&#123;&gt; public function work(): void;&gt;&#125;&gt;&gt;class Human implements Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; // ....working&gt; &#125;&gt;&#125;&gt;&gt;class Robot implements Employee&gt;&#123;&gt; public function work(): void&gt; &#123;&gt; //.... working much more&gt; &#125;&gt;&#125;&gt;&gt;class Manager&gt;&#123;&gt; private $employee;&gt;&gt; public function __construct(Employee $employee)&gt; &#123;&gt; $this-&gt;employee = $employee;&gt; &#125;&gt;&gt; public function manage(): void&gt; &#123;&gt; $this-&gt;employee-&gt;work();&gt; &#125;&gt;&#125;&gt; &gt; 别重复你的代码 (DRY) 尝试去研究DRY原则。 尽可能别去复制代码。复制代码非常不好，因为这意味着将来有需要修改的业务逻辑时你需要修改不止一处。 想象一下你在经营一个餐馆并且你需要经常整理你的存货清单：你所有的土豆，洋葱，大蒜，辣椒等。如果你有多个列表来管理进销记录，当你用其中一些土豆做菜时你需要更新所有的列表。如果你只有一个列表的话只有一个地方需要更新! 大多数情况下你有重复的代码是因为你有超过两处细微的差别，他们大部分都是相同的，但是他们的不同之处又不得不让你去分成不同的方法去处理相同的事情。移除这些重复的代码意味着你需要创建一个可以用一个方法/模块/类来处理的抽象。 使用一个抽象是关键的，这也是为什么在类中你要遵循SOLID原则的原因。一个不优雅的抽象往往比重复的代码更糟糕，所以要谨慎使用！说了这么多，如果你已经可以构造一个优雅的抽象，那就赶紧去做吧！别重复你的代码，否则当你需要修改时你会发现你要修改许多地方。 不友好的: 1234567891011121314151617181920212223242526272829303132&gt;function showDeveloperList(array $developers): void&gt;&#123;&gt; foreach ($developers as $developer) &#123;&gt; $expectedSalary = $developer-&gt;calculateExpectedSalary();&gt; $experience = $developer-&gt;getExperience();&gt; $githubLink = $developer-&gt;getGithubLink();&gt; $data = [&gt; $expectedSalary,&gt; $experience,&gt; $githubLink&gt; ];&gt;&gt; render($data);&gt; &#125;&gt;&#125;&gt;&gt;function showManagerList(array $managers): void&gt;&#123;&gt; foreach ($managers as $manager) &#123;&gt; $expectedSalary = $manager-&gt;calculateExpectedSalary();&gt; $experience = $manager-&gt;getExperience();&gt; $githubLink = $manager-&gt;getGithubLink();&gt; $data = [&gt; $expectedSalary,&gt; $experience,&gt; $githubLink&gt; ];&gt;&gt; render($data);&gt; &#125;&gt;&#125;&gt; &gt; 友好的: 12345678910111213141516&gt;function showList(array $employees): void&gt;&#123;&gt; foreach ($employees as $employee) &#123;&gt; $expectedSalary = $employee-&gt;calculateExpectedSalary();&gt; $experience = $employee-&gt;getExperience();&gt; $githubLink = $employee-&gt;getGithubLink();&gt; $data = [&gt; $expectedSalary,&gt; $experience,&gt; $githubLink&gt; ];&gt;&gt; render($data);&gt; &#125;&gt;&#125;&gt; &gt; 非常优雅的: 如果能更简洁那就更好了。 1234567891011&gt;function showList(array $employees): void&gt;&#123;&gt; foreach ($employees as $employee) &#123;&gt; render([&gt; $employee-&gt;calculateExpectedSalary(),&gt; $employee-&gt;getExperience(),&gt; $employee-&gt;getGithubLink()&gt; ]);&gt; &#125;&gt;&#125;&gt; 原文地址clean-code-php 文章首发地址：我的博客","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"代码习惯","slug":"代码习惯","permalink":"http://yoursite.com/tags/代码习惯/"},{"name":"代码简洁","slug":"代码简洁","permalink":"http://yoursite.com/tags/代码简洁/"}]},{"title":"php内存溢出分析","date":"2017-11-28T11:55:19.000Z","path":"2017/11/28/php内存溢出分析/","text":"php内存溢出原因 你写了一个php脚本，一般都不用考虑内存泄露和垃圾回收的问题，因为一般情况下你的脚本很快就执行完退出了。但在一些运行时间长，数据量大的时候，程序运行一段时间后，php脚本就占用了过多内存，然后就报错（PHP Fatal error: Allowed memory size of 134217728 bytes exhausted）退出了。一般来说，每个页面处理结束，新建的simple_html_dom对象就应该被销毁了——但是实际上没有，很明显，内存泄露发生了。 查看内存是否泄露 看是否有该释放的内存没有被释放，可以简单的通过 调用 memory_get_usage 函数查看内存使用情况来判断；memory_get_usage 函数返回的内存使用数据据说不是很准确，可以使用 php 的 xdebug 扩展来获得更准确翔实的内存使用情况 解决办法 ini_set(‘memory_limit’,’100M’); 应当尽可能减少静态变量的使用，在需要数据重用时，可以考虑使用引用(&amp;)。 数据库操作完成后，要马上关闭连接； 一个对象使用完，要及时调用析构函数（__destruct()） 用过的变量及时销毁(unset())掉 可以使用memory_get_usage()函数,获取当前占用内存 根据当前使用的内存来调整程序 unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间。(PHP内核的gc垃圾回收机制决定) 有当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存 (PHP变量底层实现是一个_zval_struct结构体,refcount_gc表示引用计数 is_ref__gc表示是否为引用)","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"内存溢出","slug":"内存溢出","permalink":"http://yoursite.com/tags/内存溢出/"}]},{"title":"php异常集中定义","date":"2017-11-22T10:35:43.000Z","path":"2017/11/22/php异常集中定义/","text":"PHP异常集中管理 最近因为接口写的较多，类似的php异常可以共用，故想着把一些exception按功能集中写在一起，以便管理和使用 exception抽象类 后面写的exception都继承于这个类 1234567891011121314151617181920212223242526272829303132333435&lt;?php/** * Created by PhpStorm. * Date: 2017/9/22 0022 * Time: 11:57 */namespace app\\exception;use think\\Exception; abstract class BaseException extends Exception&#123; protected $code ; protected $message; protected $data; public function __construct($exceptKey)&#123; $exception = $this-&gt;$exceptKey; if ($exception)&#123; $this-&gt;code = $exception[&apos;code&apos;]; $this-&gt;message = $exception[&apos;message&apos;]; &#125; &#125; public function __get($name) &#123; $res = array(); if(array_key_exists($name, $this-&gt;data)) &#123; $res = $this-&gt;data[$name]; &#125; return $res; &#125;&#125; exception继承BaseException12345678910111213141516&lt;?php/** * Created by PhpStorm. * Date: 2017/9/20 0020 * Time: 15:57 */namespace app\\exception;class BindException extends BaseException&#123; protected $data = [ &apos;USER_ID_ERROR&apos; =&gt; [&apos;code&apos;=&gt;&apos;1001&apos;,&apos;message&apos;=&gt;&apos;用户ID不正确&apos;], &apos;INVITE_CODE_ERROR&apos; =&gt; [&apos;code&apos;=&gt;&apos;1002&apos;,&apos;message&apos;=&gt;&apos;邀请码不正确&apos;], ];&#125; 接口controller中调用代码1234567891011121314151617181920212223242526&lt;?php/** * Created by PhpStorm. * Date: 2017/9/21 0021 * Time: 19:23 */namespace app\\api\\controller;use think\\Controller;use app\\common\\service\\BindService;use app\\exception\\BindException;class Bind extends Controller&#123; public function bindAgent() &#123; $bindService = new BindService; $paramArr = input(); try&#123; $bindService-&gt;checkBindParam($paramArr); &#125;catch(BindException $e) &#123; return [&apos;code&apos;=&gt;$e-&gt;getCode(),&apos;message&apos;=&gt;$e-&gt;getMessage(),&apos;data&apos;=&gt;$data=[]]; &#125; &#125;&#125; service中抛出异常1234567891011121314151617181920212223&lt;?php/** * Created by PhpStorm. * Date: 2017/9/22 0022 * Time: 10:03 */namespace app\\common\\service;use app\\exception\\BindException;class BindService&#123; public function checkBindParam($paramArr) &#123; if( !isset($paramArr[&apos;userId&apos;]) || !$paramArr[&apos;userId&apos;])&#123; throw new BindException(&apos;USER_ID_ERROR&apos;); &#125; if( !isset($paramArr[&apos;invite_code&apos;]) || !$paramArr[&apos;invite_code&apos;])&#123; throw new BindException(&apos;INVITE_CODE_ERROR&apos;); &#125; return false; &#125;&#125; exception集中定义就写到这里了，当做个人笔记记录下，同时也提供给大家参考~","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"exception","slug":"exception","permalink":"http://yoursite.com/tags/exception/"}]},{"title":"nginx配置详解","date":"2017-11-21T02:39:39.000Z","path":"2017/11/21/nginx配置详解/","text":"Nginx简介及配置文件详解参考文章 nginx基本配置与参数说明 Nginx配置文件详解 Nginx简介及配置文件详解全局变量123456789101112131415161718192021#Nginx的worker进程运行用户以及用户组#user nobody nobody;#Nginx开启的进程数worker_processes 1;#worker_processes auto;#以下参数指定了哪个cpu分配给哪个进程，一般来说不用特殊指定。如果一定要设的话，用0和1指定分配方式.#这样设就是给1-4个进程分配单独的核来运行，出现第5个进程是就是随机分配了。eg:#worker_processes 4 #4核CPU#worker_cpu_affinity 0001 0010 0100 1000#定义全局错误日志定义类型，[debug|info|notice|warn|crit]#error_log logs/error.log info;#指定进程ID存储文件位置#pid logs/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。#vim /etc/security/limits.conf# * soft nproc 65535# * hard nproc 65535# * soft nofile 65535# * hard nofile 65535worker_rlimit_nofile 65535; 事件配置123456789events &#123; #use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #每个进程可以处理的最大连接数，理论上每台nginx服务器的最大连接数为worker_processes*worker_connections。理论值：worker_rlimit_nofile/worker_processes #注意：最大客户数也由系统的可用socket连接数限制（~ 64K），所以设置不切实际的高没什么好处 worker_connections 65535; #worker工作方式：串行（一定程度降低负载，但服务器吞吐量大时，关闭使用并行方式） #multi_accept on;&#125; http参数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream;#日志相关定义 #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #定义日志的格式。后面定义要输出的内容。 #1.$remote_addr 与$http_x_forwarded_for 用以记录客户端的ip地址； #2.$remote_user ：用来记录客户端用户名称； #3.$time_local ：用来记录访问时间与时区； #4.$request ：用来记录请求的url与http协议； #5.$status ：用来记录请求状态； #6.$body_bytes_sent ：记录发送给客户端文件主体内容大小； #7.$http_referer ：用来记录从那个页面链接访问过来的； #8.$http_user_agent ：记录客户端浏览器的相关信息 #连接日志的路径，指定的日志格式放在最后。 #access_log logs/access.log main; #只记录更为严重的错误日志，减少IO压力 error_log logs/error.log crit; #关闭日志 #access_log off; #默认编码 #charset utf-8; #服务器名字的hash表大小 server_names_hash_bucket_size 128; #客户端请求单个文件的最大字节数 client_max_body_size 8m; #指定来自客户端请求头的hearerbuffer大小 client_header_buffer_size 32k; #指定客户端请求中较大的消息头的缓存最大数量和大小。 large_client_header_buffers 4 64k; #开启高效传输模式。 sendfile on; #防止网络阻塞 tcp_nopush on; tcp_nodelay on; #客户端连接超时时间，单位是秒 keepalive_timeout 60; #客户端请求头读取超时时间 client_header_timeout 10; #设置客户端请求主体读取超时时间 client_body_timeout 10; #响应客户端超时时间 send_timeout 10;#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k;#gzip模块设置 #开启gzip压缩输出 gzip on; #最小压缩文件大小 gzip_min_length 1k; #压缩缓冲区 gzip_buffers 4 16k; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_http_version 1.0; #压缩等级 1-9 等级越高，压缩效果越好，节约宽带，但CPU消耗大 gzip_comp_level 2; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_types text/plain application/x-javascript text/css application/xml; #前端缓存服务器缓存经过压缩的页面 gzip_vary on; 虚拟主机基本设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#虚拟主机定义 server &#123; #监听端口 listen 80; #访问域名 server_name localhost; #编码格式，若网页格式与此不同，将被自动转码 #charset koi8-r; #虚拟主机访问日志定义 #access_log logs/host.access.log main; #对URL进行匹配 location / &#123; #访问路径，可相对也可绝对路径 root html; #首页文件。以下按顺序匹配 index index.html index.htm; &#125;#错误信息返回页面 #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;#访问URL以.php结尾则自动转交给127.0.0.1 # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125;#php脚本请求全部转发给FastCGI处理 # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125;#禁止访问.ht页面 （需ngx_http_access_module模块） # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125;#HTTPS虚拟主机定义 # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; Nignx状态监控123456789101112#Nginx运行状态，StubStatus模块获取Nginx自启动的工作状态（编译时要开启对应功能） #location /NginxStatus &#123; # #启用StubStatus的工作访问状态 # stub_status on; # #指定StubStaus模块的访问日志文件 # access_log logs/Nginxstatus.log; # #Nginx认证机制（需Apache的htpasswd命令生成） # #auth_basic &quot;NginxStatus&quot;; # #用来认证的密码文件 # #auth_basic_user_file ../htpasswd; #&#125;访问：http://IP/NginxStatus(测试就不加密码验证相关) 反向代理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#以下配置追加在HTTP的全局变量中#nginx跟后端服务器连接超时时间(代理连接超时)proxy_connect_timeout 5;#后端服务器数据回传时间(代理发送超时)proxy_send_timeout 5;#连接成功后，后端服务器响应时间(代理接收超时)proxy_read_timeout 60;#设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffer_size 16k;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置proxy_buffers 4 32k;#高负荷下缓冲大小（proxy_buffers*2）proxy_busy_buffers_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传proxy_temp_file_write_size 64k;#反向代理缓存目录proxy_cache_path /data/proxy/cache levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=1g;#levels=1:2 设置目录深度，第一层目录是1个字符，第2层是2个字符#keys_zone:设置web缓存名称和内存缓存空间大小#inactive:自动清除缓存文件时间。#max_size:硬盘空间最大可使用值。#指定临时缓存文件的存储路径(路径需和上面路径在同一分区)proxy_temp_path /data/proxy/temp#服务配置server &#123; #侦听的80端口 listen 80; server_name localhost; location / &#123; #反向代理缓存设置命令(proxy_cache zone|off,默认关闭所以要设置) proxy_cache cache_one; #对不同的状态码缓存不同时间 proxy_cache_valid 200 304 12h; #设置以什么样参数获取缓存文件名 proxy_cache_key $host$uri$is_args$args; #后7端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #代理设置 proxy_pass http://IP; #文件过期时间控制 expires 1d; &#125; #配置手动清楚缓存(实现此功能需第三方模块 ngx_cache_purge) #http://www.123.com/2017/0316/17.html访问 #http://www.123.com/purge/2017/0316/17.html清楚URL缓存 location ~ /purge(/.*) &#123; allow 127.0.0.1; deny all; proxy_cache_purge cache_one $host$1$is_args$args; &#125; #设置扩展名以.jsp、.php、.jspx结尾的动态应用程序不做缓存 location ~.*\\.(jsp|php|jspx)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://http://IP; &#125; 负载均衡12345678910111213141516171819202122#负载均衡服务器池upstream my_server_pool &#123; #调度算法 #1.轮循（默认）（weight轮循权值） #2.ip_hash：根据每个请求访问IP的hash结果分配。（会话保持） #3.fair:根据后端服务器响应时间最短请求。（upstream_fair模块） #4.url_hash:根据访问的url的hash结果分配。（需hash软件包） #参数： #down：表示不参与负载均衡 #backup:备份服务器 #max_fails:允许最大请求错误次数 #fail_timeout:请求失败后暂停服务时间。 server 192.168.1.109:80 weight=1 max_fails=2 fail_timeout=30; server 192.168.1.108:80 weight=2 max_fails=2 fail_timeout=30;&#125;#负载均衡调用server &#123; ... location / &#123; proxy_pass http://my_server_pool; &#125;&#125; URL重写123456789101112#根据不同的浏览器URL重写if($http_user_agent ~ Firefox)&#123;rewrite ^(.*)$ /firefox/$1 break;&#125;if($http_user_agent ~ MSIE)&#123;rewrite ^(.*)$ /msie/$1 break;&#125;#实现域名跳转location / &#123; rewrite ^/(.*)$ https://web8.example.com$1 permanent;&#125; IP限制1234567#限制IP访问location / &#123; deny 192.168.0.2； allow 192.168.0.0/24; allow 192.168.1.1; deny all;&#125; Nginx相关命令123456#启动nginxnginx#关闭nginxnginx -s stop#平滑重启kill -HUP `cat /usr/local/nginx/logs/nginx.pid` Nginx启动脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/bin/bash#chkconfig: 2345 80 90#description:auto_runPATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# Check if user is rootif [ $(id -u) != &quot;0&quot; ]; then echo &quot;Error: You must be root to run this script!\\n&quot; exit 1fiNGINXDAEMON=/usr/local/nginx/sbin/nginxPIDFILE=/usr/local/nginx/logs/nginx.pidfunction_start()&#123; echo -en &quot;\\033[32;49;1mStarting nginx......\\n&quot; echo -en &quot;\\033[39;49;0m&quot; if [ -f $PIDFILE ]; then printf &quot;Nginx is runing!\\n&quot; exit 1 else $NGINXDAEMON printf &quot;Nginx is the successful start!\\n&quot; fi&#125;function_stop()&#123; echo -en &quot;\\033[32;49;1mStoping nginx......\\n&quot; echo -en &quot;\\033[39;49;0m&quot; if [ -f $PIDFILE ]; then kill `cat $PIDFILE` printf &quot;Nginx program is stoped\\n&quot; else printf &quot;Nginx program is not runing!\\n&quot; fi&#125;function_reload()&#123; echo -en &quot;\\033[32;49;1mReload nginx......\\n&quot; echo -en &quot;\\033[39;49;0m&quot; function_stop function_start&#125;function_restart()&#123; echo -en &quot;\\033[32;49;1mRestart nginx......\\n&quot; echo -en &quot;\\033[39;49;0m&quot; printf &quot;Reload Nginx configure...\\n&quot; $NGINXDAEMON -t kill -HUP `cat $PIDFILE` printf &quot;Nginx program is reloding!\\n&quot;&#125;function_kill()&#123; killall nginx&#125;function_status()&#123; if ! ps -ef|grep -v grep|grep &apos;nginx:&apos; &gt; /dev/null 2&gt;&amp;1 then printf &quot;Nginx is down!!!\\n&quot; else printf &quot;Nginx is running now!\\n&quot; fi&#125;if [ &quot;$1&quot; = &quot;start&quot; ]; then function_startelif [ &quot;$1&quot; = &quot;stop&quot; ]; then function_stopelif [ &quot;$1&quot; = &quot;reload&quot; ]; then function_reloadelif [ &quot;$1&quot; = &quot;restart&quot; ]; then function_restartelif [ &quot;$1&quot; = &quot;kill&quot; ]; then function_killelif [ &quot;$1&quot; = &quot;status&quot; ]; then function_statuselse echo -en &quot;\\033[32;49;1m Usage: nginx &#123;start|stop|reload|restart|kill|status&#125;\\n&quot; echo -en &quot;\\033[39;49;0m&quot;fi","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"mysql性能优化","date":"2017-10-24T12:12:13.000Z","path":"2017/10/24/mysql性能优化/","text":"一、 优化概述MySQL数据库是常见的两个瓶颈是CPU和I/O的瓶颈，CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候。磁盘I/O瓶颈发生在装入数据远大于内存容量的时候，如果应用分布在网络上，那么查询量相当大的时候那么平瓶颈就会出现在网络上，我们可以用mpstat, iostat, sar和vmstat来查看系统的性能状态。 除了服务器硬件的性能瓶颈，对于MySQL系统本身，我们可以使用工具来优化数据库的性能，通常有三种：使用索引，使用EXPLAIN分析查询以及调整MySQL的内部配置。 二、查询与索引优化分析在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有慢查询日志，EXPLAIN 分析查询，profiling分析以及show命令查询系统状态及系统变量，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。 性能瓶颈定位Show命令我们可以通过show命令查看MySQL状态及变量，找到系统的瓶颈： 1234567891011Mysql&gt; show status ——显示状态信息（扩展show status like ‘XXX’）Mysql&gt; show variables ——显示系统变量（扩展show variables like ‘XXX’）Mysql&gt; show innodb status ——显示InnoDB存储引擎的状态Mysql&gt; show processlist ——查看当前SQL执行，包括执行状态、是否锁表等Shell&gt; mysqladmin variables -u username -p password——显示系统变量Shell&gt; mysqladmin extended-status -u username -p password——显示状态信息 查看状态变量及帮助： 1Shell&gt; mysqld –verbose –help [|more #逐行显示] 比较全的Show命令的使用可参考： http://blog.phpbean.com/a.cn/18/ 慢查询日志 慢查询日志开启： 在配置文件my.cnf或my.ini中在[mysqld]一行下面加入两个配置参数 123log-slow-queries=/data/mysqldata/slow-query.loglong_query_time=2 注：log-slow-queries参数为慢查询日志存放的位置，一般这个目录要有mysql的运行帐号的可写权限，一般都将这个目录设置为mysql的数据存放目录； long_query_time=2中的2表示查询超过两秒才记录； 在my.cnf或者my.ini中添加log-queries-not-using-indexes参数，表示记录下没有使用索引的查询。 log-slow-queries=/data/mysqldata/slow-query.log long_query_time=10 log-queries-not-using-indexes 慢查询日志开启方法二： 我们可以通过命令行设置变量来即时启动慢日志查询。由下面代码可知慢日志没有打开，slow_launch_time=# 表示如果建立线程花费了比这个值更长的时间,slow_launch_threads 计数器将增加 123456789mysql&gt; show variables like &apos;slow%&apos;;+---------------------+-----------------------------------------+| Variable_name | Value |+---------------------+-----------------------------------------+| slow_launch_time | 2 || slow_query_log | OFF || slow_query_log_file | /usr/local/mysql/var/localhost-slow.log |+---------------------+-----------------------------------------+3 rows in set (0.00 sec) 设置慢日志开启12345678910111213141516171819202122mysql&gt; show variables like &apos;slow%&apos;;+---------------------+-----------------------------------------+| Variable_name | Value |+---------------------+-----------------------------------------+| slow_launch_time | 2 || slow_query_log | OFF || slow_query_log_file | /usr/local/mysql/var/localhost-slow.log |+---------------------+-----------------------------------------+3 rows in set (0.00 sec)mysql&gt; set global slow_query_log = on;Query OK, 0 rows affected (0.05 sec)mysql&gt; show variables like &apos;slow%&apos;;+---------------------+-----------------------------------------+| Variable_name | Value |+---------------------+-----------------------------------------+| slow_launch_time | 2 || slow_query_log | ON || slow_query_log_file | /usr/local/mysql/var/localhost-slow.log |+---------------------+-----------------------------------------+3 rows in set (0.00 sec) MySQL后可以查询long_query_time 的值 。 1234567mysql&gt; show variables like &apos;long%&apos;;+-----------------+-----------+| Variable_name | Value |+-----------------+-----------+| long_query_time | 10.000000 |+-----------------+-----------+1 row in set (0.01 sec) 为了方便测试，可以将修改慢查询时间为1秒。12345678910mysql&gt; set long_query_time = 5;Query OK, 0 rows affected (0.00 sec)mysql&gt; show variables like &apos;long%&apos;;+-----------------+----------+| Variable_name | Value |+-----------------+----------+| long_query_time | 5.000000 |+-----------------+----------+1 row in set (0.00 sec) 慢查询分析mysqldumpslow我们可以通过打开log文件查看得知哪些SQL执行效率低下 123456789[root@localhost mysql]# more slow-query.log# Time: 081026 19:46:34# User@Host: root[root] @ localhost []# Query_time: 11 Lock_time: 0 Rows_sent: 1 Rows_examined: 6552961select count(*) from t_user; 从日志中，可以发现查询时间超过5 秒的SQL，而小于5秒的没有出现在此日志中。 如果慢查询日志中记录内容很多，可以使用mysqldumpslow工具（MySQL客户端安装自带）来对慢查询日志进行分类汇总。mysqldumpslow对日志文件进行了分类汇总，显示汇总后摘要结果。 进入log的存放目录，运行 1234567[root@mysql_data]#mysqldumpslow slow-query.logReading mysql slow query log from slow-query.logCount: 2 Time=11.00s (22s) Lock=0.00s (0s) Rows=1.0 (2), root[root]@mysqlselect count(N) from t_user; mysqldumpslow命令 1/path/mysqldumpslow -s c -t 10 /database/mysql/slow-query.log 这会输出记录次数最多的10条SQL语句，其中： -s, 是表示按照何种方式排序，c、t、l、r分别是按照记录次数、时间、查询时间、返回的记录数来排序，ac、at、al、ar，表示相应的倒叙； -t, 是top n的意思，即为返回前面多少条的数据； -g, 后边可以写一个正则匹配模式，大小写不敏感的； 例如：1/path/mysqldumpslow -s r -t 10 /database/mysql/slow-log 得到返回记录集最多的10个查询。1/path/mysqldumpslow -s t -t 10 -g “left join” /database/mysql/slow-log 得到按照时间排序的前10条里面含有左连接的查询语句。 使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化是MySQL优化非常重要的一步。开启慢查询日志后，由于日志记录操作，在一定程度上会占用CPU资源影响mysql的性能，但是可以阶段性开启来定位性能瓶颈。 explain分析查询使用 EXPLAIN 关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。通过explain命令可以得到: 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; describe t_web_log;+------------+----------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+----------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || uid | smallint(5) unsigned | NO | MUL | NULL | || ip | char(15) | NO | MUL | NULL | || location | varchar(255) | NO | | NULL | || os | varchar(255) | NO | | NULL | || browser | varchar(255) | NO | | NULL | || url | varchar(255) | NO | | NULL | || module | char(6) | NO | MUL | NULL | || controller | varchar(255) | NO | MUL | NULL | || action | varchar(255) | NO | | | || method | varchar(10) | NO | MUL | GET | || data | text | NO | | NULL | || otime | int(10) unsigned | NO | MUL | NULL | |+------------+----------------------+------+-----+---------+----------------+13 rows in set (0.01 sec)mysql&gt; EXPLAIN SELECT * FROM t_web_log WHERE controller = &apos;Login&apos; -&gt; ;+----+-------------+-----------+------+---------------+------------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-------------+| 1 | SIMPLE | t_web_log | ref | controller | controller | 767 | const | 245 | Using where |+----+-------------+-----------+------+---------------+------------+---------+-------+------+-------------+1 row in set (0.00 sec)mysql&gt; EXPLAIN SELECT * FROM t_web_log WHERE controller = &apos;Login&apos; AND uid = 1 -&gt; ;+----+-------------+-----------+------+----------------+------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-----------+------+----------------+------+---------+-------+------+-------------+| 1 | SIMPLE | t_web_log | ref | uid,controller | uid | 2 | const | 40 | Using where |+----+-------------+-----------+------+----------------+------+---------+-------+------+-------------+1 row in set (0.00 sec) EXPLAIN字段： Table：显示这一行的数据是关于哪张表的 possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 key：实际使用的索引。如果为NULL，则没有使用索引。MYSQL很少会选择优化不足的索引，此时可以在SELECT语句中使用USE INDEX（index）来强制使用一个索引或者用IGNORE INDEX（index）来强制忽略索引 key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref：显示索引的哪一列被使用了，如果可能的话，是一个常数 rows：MySQL认为必须检索的用来返回请求数据的行数 type：这是最重要的字段之一，显示查询使用了何种类型。从最好到最差的连接类型为system、const、eq_reg、ref、range、index和ALL system、const：可以将查询的变量转为常量. 如id=1; id为 主键或唯一键. eq_ref：访问索引,返回某单一行的数据.(通常在联接时出现，查询使用的索引为主键或惟一键) ref：访问索引,返回某个值的数据.(可以返回多行) 通常使用=时发生 range：这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西，并且该字段上建有索引时发生的情况(注:不一定好于index) index：以索引的顺序进行全表扫描，优点是不用排序,缺点是还要全表扫描 ALL：全表扫描，应该尽量避免 Extra：关于MYSQL如何解析查询的额外信息，主要有以下几种 using index：只用到索引,可以避免访问表. using where：使用到where来过虑数据. 不是所有的where clause都要显示using where. 如以=方式访问索引. using tmporary：用到临时表 using filesort：用到额外的排序. (当使用order by v1,而没用到索引时,就会使用额外的排序) range checked for eache record(index map:N)：没有好的索引. 1EXPLAIN SELECT * FROM t_web_log WHERE uid &gt; 1 profiling分析查询通过慢日志查询可以知道哪些SQL语句执行效率低下，通过explain我们可以得知SQL语句的具体执行情况，索引使用等，还可以结合show命令查看执行状态。 如果觉得explain的信息不够详细，可以同通过profiling命令得到更准确的SQL执行消耗系统资源的信息。 profiling默认是关闭的。可以通过以下语句查看 1234567mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+| 0 |+-------------+1 row in set (0.00 sec) 打开功能： mysql&gt;set profiling=1; 执行需要测试的sql 语句： 123456789101112131415161718192021222324252627mysql&gt; set profiling=1;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM t_web_log WHERE uid &gt; 1;ERROR 1046 (3D000): No database selectedmysql&gt; use whmj_agent;Database changedmysql&gt; SELECT * FROM t_web_log WHERE uid &gt; 1;Empty set (0.00 sec)mysql&gt; show profiles\\G;*************************** 1. row ***************************Query_ID: 1Duration: 0.00020475 Query: SELECT * FROM t_web_log WHERE uid &gt; 1*************************** 2. row ***************************Query_ID: 2Duration: 0.00007125 Query: SELECT DATABASE()*************************** 3. row ***************************Query_ID: 3Duration: 0.00015775 Query: SELECT * FROM t_web_log WHERE uid &gt; 13 rows in set (0.00 sec)ERROR:No query specified 123mysql&gt; show profiles\\G; 可以得到被执行的SQL语句的时间和IDmysql&gt;show profile for query 1; 得到对应SQL语句执行的详细信息 Show Profile命令格式：12345678910111213141516171819202122232425SHOW PROFILE [type [, type] … ] [FOR QUERY n] [LIMIT row_count [OFFSET offset]]type: ALL | BLOCK IO | CONTEXT SWITCHES | CPU | IPC | MEMORY | PAGE FAULTS | SOURCE | SWAPS 以上的16rows是针对非常简单的select语句的资源信息，对于较复杂的SQL语句，会有更多的行和字段，比如converting HEAP to MyISAM 、Copying to tmp table等等，由于以上的SQL语句不存在复杂的表操作，所以未显示这些字段。通过profiling资源耗费信息，我们可以采取针对性的优化措施。 测试完毕以后 ，关闭参数：1mysql&gt; set profiling=0 三、索引及查询优化索引的类型 普通索引：这是最基本的索引类型，没唯一性之类的限制。 唯一性索引：和普通索引基本相同，但所有的索引列值保持唯一性。 主键：主键是一种唯一索引，但必须指定为”PRIMARY KEY”。 全文索引：MYSQL从3.23.23开始支持全文索引和全文检索。在MYSQL中，全文索引的索引类型为FULLTEXT。全文索引可以在VARCHAR或者TEXT类型的列上创建。 大多数MySQL索引(PRIMARY KEY、UNIQUE、INDEX和FULLTEXT)使用B树中存储。空间列类型的索引使用R-树，MEMORY表支持hash索引。 单列索引和多列索引（复合索引） 索引可以是单列索引，也可以是多列索引。对相关的列使用索引是提高SELECT操作性能的最佳途径之一。 多列索引MySQL可以为多个列创建索引。一个索引可以包括15个列。对于某些列类型，可以索引列的左前缀，列的顺序非常重要。 多列索引可以视为包含通过连接索引列的值而创建的值的排序的数组。一般来说，即使是限制最严格的单列索引，它的限制能力也远远低于多列索引。 最左前缀 多列索引有一个特点，即最左前缀（Leftmost Prefixing）。假如有一个多列索引为key(firstname lastname age)，当搜索条件是以下各种列的组合和顺序时，MySQL将使用该多列索引： firstname，lastname，age firstname，lastname firstname 也就是说，相当于还建立了key(firstname lastname)和key(firstname)。 索引主要用于下面的操作： 快速找出匹配一个WHERE子句的行。 删除行。当执行联接时，从其它表检索行。 对具体有索引的列key_col找出MAX()或MIN()值。由预处理器进行优化，检查是否对索引中在key_col之前发生所有关键字元素使用了WHERE keypart# = constant。在这种情况下，MySQL为每个MIN()或MAX()表达式执行一次关键字查找，并用常数替换它。如果所有表达式替换为常量，查询立即返回。例如： SELECT MIN(key2), MAX (key2) FROM tb WHERE key1=10; 如果对一个可用关键字的最左面的前缀进行了排序或分组(例如，ORDER BY key_part_1,key_part_2)，排序或分组一个表。如果所有关键字元素后面有DESC，关键字以倒序被读取。 在一些情况中，可以对一个查询进行优化以便不用查询数据行即可以检索值。如果查询只使用来自某个表的数字型并且构成某些关键字的最左面前缀的列，为了更快，可以从索引树检索出值。 SELECT key_part3 FROM tb WHERE key_part1=1 有时MySQL不使用索引，即使有可用的索引。一种情形是当优化器估计到使用索引将需要MySQL访问表中的大部分行时。(在这种情况下，表扫描可能会更快些）。然而，如果此类查询使用LIMIT只搜索部分行，MySQL则使用索引，因为它可以更快地找到几行并在结果中返回。例如：1234567mysql&gt; EXPLAIN SELECT * FROM t_web_log WHERE module = &apos;admin&apos;;+----+-------------+-----------+------+---------------+------+---------+------+-------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-----------+------+---------------+------+---------+------+-------+-------------+| 1 | SIMPLE | t_web_log | ALL | module | NULL | NULL | NULL | 16676 | Using where |+----+-------------+-----------+------+---------------+------+---------+------+-------+-------------+1 row in set (0.00 sec) 合理的建立索引的建议 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值 这部分是关于索引和写SQL语句时应当注意的一些琐碎建议和注意点。 123456781. 当结果集只有一行数据时使用LIMIT 12. 避免SELECT *，始终指定你需要的列,从表中读取越多的数据，查询会变得更慢。他增加了磁盘需要操作的时间，还是在数据库服务器与WEB服务器是独立分开的情况下。你将会经历非常漫长的网络延迟，仅仅是因为数据不必要的在服务器之间传输。3. 使用连接（JOIN）来代替子查询(Sub-Queries),连接（JOIN）.. 之所以更有效率一些，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作,但是两个大表尽量不要联表查询。4. 使用ENUM、CHAR 而不是VARCHAR，使用合理的字段属性长度5. 尽可能的使用NOT NULL6. 固定长度的表会更快7. 拆分大的DELETE 或INSERT 语句8. 查询的列越小越快 Where条件在查询中，WHERE条件也是一个比较重要的因素，尽量少并且是合理的where条件是很重要的，尽量在多个条件的时候，把会提取尽量少数据量的条件放在前面，减少后一个where条件的查询时间。 有些where条件会导致索引无效： where子句的查询条件里有！=，MySQL将无法使用索引。 where子句使用了Mysql函数的时候，索引将无效，比如：select * from tb where left(name, 4) = ‘xxx’ 使用LIKE进行搜索匹配的时候，这样索引是有效的：select * from tbl1 where name like ‘xxx%’，而like ‘%xxx%’ 时索引无效 三、配置优化安装MySQL后，配置文件my.cnf在 /MySQL安装目录/share/mysql目录中，该目录中还包含多个配置文件可供参考，有my-large.cnf ，my-huge.cnf， my-medium.cnf，my-small.cnf，分别对应大中小型数据库应用的配置。win环境下即存在于MySQL安装目录中的.ini文件。 下面列出了对性能优化影响较大的主要变量，主要分为连接请求的变量和缓冲区变量。 请求的变量 max_connections MySQL的最大连接数，增加该值增加mysqld 要求的文件描述符的数量。如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。 数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。 123show variables like ‘max_connections’ 最大连接数show status like ‘max_used_connections’响应的连接数 如下：1234567891011121314151617181920212223mysql&gt; show variables like ‘max_connections‘;+———————–+——-+| Variable_name | Value |+———————–+——-+| max_connections | 256 |+———————–+——-+mysql&gt; show status like ‘max%connections‘;+———————–+——-+| Variable_name | Value |+—————————-+——-+| max_used_connections | 256|+—————————-+——-+ max_used_connections / max_connections * 100% （理想值≈ 85%）如果max_used_connections跟max_connections相同 那么就是max_connections设置过低或者超过服务器负载上限了，低于10%则设置过大。 back_log MySQL能暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用。如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。 back_log值指出在MySQL暂时停止回答新请求之前的短时间内有多少个请求可以被存在堆栈中。只有如果期望在一个短时间内有很多连接，你需要增加它，换句话说，这值对到来的TCP/IP连接的侦听队列的大小。 当观察你主机进程列表（mysql&gt; show full processlist），发现大量264084 | unauthenticated user | xxx.xxx.xxx.xxx | NULL | Connect | NULL | login | NULL 的待连接进程时，就要加大back_log 的值了。 默认数值是50，可调优为128，对于Linux系统设置范围为小于512的整数。 interactive_timeout一个交互连接在被服务器在关闭前等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE 选项的客户。 默认数值是28800，可调优为7200。 缓冲区变量 全局缓冲： key_buffer_size key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。 key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。 举例如下： 123456789101112131415161718192021222324252627mysql&gt; show variables like ‘key_buffer_size‘;+——————-+————+| Variable_name | Value |+———————+————+| key_buffer_size | 536870912 |+———— ———-+————+key_buffer_size为512MB，我们再看一下key_buffer_size的使用情况：mysql&gt; show global status like ‘key_read%‘;+————————+————-+| Variable_name | Value |+————————+————-+| Key_read_requests| 27813678764 || Key_reads | 6798830 |+————————+————-+ 一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率： key_cache_miss_rate ＝Key_reads / Key_read_requests * 100%，设置在1/1000左右较好 默认配置数值是8388600(8M)，主机有4GB内存，可以调优值为268435456(256MB)。 query_cache_size 使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。 通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。 与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。 query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。 query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。 query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小query_cache_min_res_unit。 举例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; show global status like ‘qcache%‘;+——————————-+—————–+| Variable_name | Value |+——————————-+—————–+| Qcache_free_blocks | 22756 || Qcache_free_memory | 76764704 || Qcache_hits | 213028692 || Qcache_inserts | 208894227 || Qcache_lowmem_prunes | 4010916 || Qcache_not_cached | 13385031 || Qcache_queries_in_cache | 43560 || Qcache_total_blocks | 111212 |+——————————-+—————–+mysql&gt; show variables like ‘query_cache%‘;+————————————–+————–+| Variable_name | Value |+————————————–+———–+| query_cache_limit | 2097152 || query_cache_min_res_unit | 4096 || query_cache_size | 203423744 || query_cache_type | ON || query_cache_wlock_invalidate | OFF |+————————————–+—————+ 查询缓存碎片率= Qcache_free_blocks / Qcache_total_blocks * 100% 如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。 查询缓存利用率= (query_cache_size – Qcache_free_memory) / query_cache_size * 100% 查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。 查询缓存命中率= (Qcache_hits – Qcache_inserts) / Qcache_hits * 100% 示例服务器查询缓存碎片率＝20.46％，查询缓存利用率＝62.26％，查询缓存命中率＝1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。 每个连接的缓冲 record_buffer_size每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。 默认数值是131072(128K)，可改为16773120 (16M) read_rnd_buffer_size随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。 一般可设置为16M sort_buffer_size每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。 默认数值是2097144(2M)，可改为16777208 (16M)。 join_buffer_size联合查询操作所能使用的缓冲区大小 record_buffer_size，read_rnd_buffer_size，sort_buffer_size，join_buffer_size为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100 table_cache表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。 1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。 max_heap_table_size用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size=# 这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。 tmp_table_size通过设置tmp_table_size选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。 123456789101112131415mysql&gt; show global status like ‘created_tmp%‘;+——————————–+———+| Variable_name | Value |+———————————-+———+| Created_tmp_disk_tables | 21197 || Created_tmp_files | 58 || Created_tmp_tables | 1771587 |+——————————–+———–+ 每次创建临时表，Created_tmp_tables增加，如果临时表大小超过tmp_table_size，则是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是： Created_tmp_disk_tables / Created_tmp_tables 100% &lt;= 25%比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables 100% ＝1.20%，应该相当好了 默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I/O堵塞 thread_cache_size可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。 通过比较 Connections和Threads_created状态的变量，可以看到这个变量的作用。 默认值为110，可调优为80。 thread_concurrency推荐设置为服务器 CPU核数的2倍，例如双核的CPU, 那么thread_concurrency的应该为4；2个双核的cpu, thread_concurrency的值应为8。默认为8 wait_timeout指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。 配置InnoDB的几个变量 innodb_buffer_pool_size 对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。 根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。 innodb_flush_log_at_trx_commit 主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。 根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。 innodb_log_buffer_size log缓存大小，一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。 可设置为4M或8M。 innodb_additional_mem_pool_size 该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。 根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。 innodb_thread_concurrency=8 推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"},{"name":"慢查询","slug":"慢查询","permalink":"http://yoursite.com/tags/慢查询/"}]},{"title":"mysql索引的数据结构和算法","date":"2017-10-19T06:40:21.000Z","path":"2017/10/19/mysql索引的数据结构和算法/","text":"摘要大学里面，学习数据结构与算法时，里面讲到：程序=数据结构+算法，不过写了这几年代码，始终没感觉有用到数据结构和算法。近来，偶尔看到有文章写mysql索引后的数据结构和算法，颇有收获，特此记录下重点。 文章主要分三部分： 从数据结构及算法理论层面讨论MySQL数据库索引的数理基础。 MySQL数据库中MyISAM和InnoDB数据存储引擎中索引的架构实现讨论聚集索引、非聚集索引及覆盖索引等 探讨如何在MySQL中高性能使用索引的 数据结构和算法索引本质 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。 我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 看个例子 图中展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)O(log2n)的复杂度内获取到相应数据。 这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。 B-Tree和B+Tree目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。 B-Tree为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构： d为大于1的一个正整数，称为B-Tree的度。2.h为一个正整数，称为B-Tree的高度。 每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。5.所有叶节点具有相同的深度，等于树高h。6.key和指针互相间隔，节点两端是指针。7.一个节点中的key从左到右非递减排列。8.所有节点组成树结构。 每个指针要么为null，要么指向另外一个节点。 如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。 如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。 如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。 如图是个d=2的B-Tree示意图 由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下： 123456789101112BTree_Search(node, key)&#123; if(node == null) return null; foreach(node.key) &#123; if(node.key[i] == key) return node.data[i]; if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node); &#125; return BTree_Search(point[i+1]-&gt;node);&#125; data = BTree_Search(root, my_key); 关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。 另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法。 B+TreeB-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。 与B-Tree相比，B+Tree有以下不同点：1.每个节点的指针上限为2d而不是2d+1。2.内节点不存储data，只存储key；叶子节点不存储指针。 如图所示是个简单的B+Tree MySQL索引实现在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。 MyISAM索引实现MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图： 这里设表一共有三列，假设我们以Col1为主键，则图中是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示： 同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。 MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分 InnoDB索引实现虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。 第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 图中是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引： 这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。 如何在MySQL中高性能使用索引，将会在下一篇文章继续探讨 ​","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"}]},{"title":"private和protected的问题","date":"2017-10-12T12:08:59.000Z","path":"2017/10/12/private和protected的问题/","text":"一、二者区别 加上public 内部 子类 外部 public √ √ √ protected √ √ × private √ × × 二、问题分析(1)看下面两段代码 代码1 12345678910111213141516171819202122232425class Human &#123; protected $name = &apos;li san&apos;; protected $money; public $age ;&#125;class Stu extends Human &#123; public function __construct() &#123; $this-&gt;name = &apos;li si&apos;; $this-&gt;money = 300; $this-&gt;age = 26; &#125; private $friend = &apos;zhang san&apos;; public function talk() &#123; echo &apos;我叫&apos;.$this-&gt;name.PHP_EOL; &#125;&#125;$ming = new Stu();$ming-&gt;talk();echo $ming-&gt;name.PHP_EOL; 运行结果：12我叫li siPHP Fatal error: Cannot access protected property Stu::$name 将类human中的name属性改为 private，得到代码2 代码2 12345678910111213141516171819202122232425class Human &#123; private $name = &apos;li san&apos;; protected $money; public $age ;&#125;class Stu extends Human &#123; public function __construct() &#123; $this-&gt;name = &apos;li si&apos;; $this-&gt;money = 300; $this-&gt;age = 26; &#125; private $friend = &apos;zhang san&apos;; public function talk() &#123; echo &apos;我叫&apos;.$this-&gt;name.PHP_EOL; &#125;&#125;$ming = new Stu();$ming-&gt;talk();echo $ming-&gt;name.PHP_EOL; 运行结果：12我叫li sili si (2)结论 代码1中name属性为protected ，代码2中为private，为什么在代码1中访问name会报错，反而2中不会报错 根据上面的private和protected的区别，父类的name为private时，子类时访问不到的，此时子类的构造方法里面$this-&gt;name，相当于==新建了一个name属性且为public==，所以能访问；父类的name为protected时，==子类修改的其实是继承过来的protected属性==，外部当然不能访问了","tags":[{"name":"问题探究","slug":"问题探究","permalink":"http://yoursite.com/tags/问题探究/"}]},{"title":"php浮点数问题","date":"2017-10-07T07:44:58.000Z","path":"2017/10/07/php浮点数问题/","text":"一、两个浮点数运算问题1、小数乘以100 代码： 1234$a = 20.40;echo $a.PHP_EOL;$b = intval($a*100);echo $b.PHP_EOL; 结果： 1220.42039 再看另一段代码： 1234567$a = 20.4;$b = $a * 100; //其实很多小数都有类似问题，也不限于PHPecho (string) $b . PHP_EOL;echo (int) $b .PHP_EOL;echo floor($b) .PHP_EOL;echo ceil($b) . PHP_EOL;echo (int)(string) $b . PHP_EOL; 运行结果： 1234520402039203920402040 2、两个浮点数比较大小 代码： 12345$a = 0.1;$b = 0.9;$c = 1;var_dump(($a+$b)==$c);var_dump(($c-$b)==$a); 运行结果： 12truefalse 看完这两个问题，我相信很多同学会有一种疑问，这个是php的bug吗？且看下面的问题分析 二、问题分析1、浮点数的表示要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754): 浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位) 符号位：最高位表示数据的正负，0表示正数，1表示负数。 指数位：表示数据以2为底的幂，指数采用偏移码表示 尾数：表示数据小数点后的有效数字.然后我们需要了解的是浮点数如何转换为二进制数 2、浮现数转二进制方法 整数部分采用除以2取余方法 小数部分采用乘以2取整方法 例如： 把数字8.5转为二进制 整数部分是8 8/2=4 8%2=0 4/2=2 4%2=0 2/2=1 2%2=0 1比2小，因此不需要计算下去，整数8的二进制为 1000 小数部分是0.5 0.5x2 = 1.0 因取整后小数部分为0，因此不需要再计算下去 小数0.5的二进制为 0.1 8.5的二进制为1000.1 3、运算问题1 根据上面关于浮点数表示的解释，20.4转换为二进制64位浮点数为：0100000000110100011001100110011001100110011001100110011001100110,小数部分0.4转换为二进制来说，是无限长的，再乘以100时，截断52位来计算的话就是20.399999999…,再乘以100，int转换为整数，就是2039了 4、运算问题2这个问题中，0.9在转换为二进制时，同样也会有精度丢失的问题 看下面这段代码： 12345$a = 0.1;$b = 0.9;$c = 1;printf(&quot;%.20f&quot;, $a+$b);printf(&quot;%.20f&quot;, $c-$b); 运行结果： 121.000000000000000000000.09999999999999997780 三、综合1、简单乘法 我在开发时，曾经多次遇到小数乘以100，得到错误结果的问题，初步可以转换为string类型解决 2、高精度运算方法 使用高精度的运算方法，这样可以保证精度不丢失。 高精度运算的方法如下： bcadd 将两个高精度数字相加 bccomp 比较两个高精度数字，返回-1,0,1 bcdiv 将两个高精度数字相除 bcmod 求高精度数字余数 bcmul 将两个高精度数字相乘 bcpow 求高精度数字乘方 bcpowmod 求高精度数字乘方求模 bcscale 配置默认小数点位数，相当于Linux bc中的”scale=” csqrt 求高精度数字平方根 bcsub 将两个高精度数字相减 代码：12345$a = 0.1;$b = 0.9;$c = 1;var_dump(($c-$b)==$a);var_dump(bcsub($c, $b, 1)==$a); 运行结果：12falsetrue php计算的问题还有可能和操作系统的位数相关，比如32位和64位，这些大家可以研究下~","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"序言","date":"2017-10-06T03:53:03.000Z","path":"2017/10/06/随笔/","text":"一、由来1、前世 其实，在一年以前我就已经用hexo加github搭建过个人的博客。去年的时候，偶然看到我一个高中好哥们的博客,他的博客就是用hexo+github搭的，不过那个时候仅仅是想作为一个相册使用，里面放的都是我自己和女朋友的一些照片。后来，懒得去维护了，空间和域名都渐渐荒废了。之前的那个博客可以算的上是这个的前世 2、今生 前段时间申请了自己的一个域名:lili-web.com,想着去阿里云买一台服务器，搭一个自己的技术博客。去阿里云上的服务器看了下价格，摸了摸自己的荷包，并且买了服务器还得去备案，麻烦~正愁着咋办，我突然想起，自己一年多用github+hexo搭建博客，不仅免费，而且不用去备案。于是开干，在网上参考了别人搭建github博客的文章，花了一天多的时间，搭建了该博客！ 二、展望1、博客 先定一个小目标，比如说。。。。。，想多了。。。。，坚持每周写一篇博客，不管是技术的还是其他的 2、go 本人是从事php开发工作的，感觉php能做的事还是比较局限，进来在学习golang 3、money 我博客取名叫lemon，其实是取得“来 money”的意思，简称lemon~要结婚、还贷、装修等等，到处是花钱的地方，所以要赶紧挣钱了。。。大家有网站开发类的私活可以找我哈~","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"Github+Hexo搭建博客","date":"2017-10-05T08:30:44.000Z","path":"2017/10/05/Github-Hexo搭建博客/","text":"一、环境搭建1.NodeJS 安装NodeJS：http://nodejs.cn/download/ 下载.msi文件，不需要配置环境变量 2.github 安装git ssh工具：https://git-for-windows.github.io/ 配置git环境，推荐教程：https://www.liaoxuefeng.com 3.hexo 安装Hexo: npm install -g hexo 初始化Hexo: hexo init 生成静态页面：hexo generate 或者 hexo g 启动服务器：hexo server 或者 hexo s 浏览器中访问：http://localhost:4000 二、更换主题及主题配置1.更换主题 默认主题是landscape，在themes文件夹下，可以使用别人开发好的主题，这里有很多，我使用的是这一个: https://github.com/litten/hexo-theme-yilia下载之后放到themes文件夹下即可：git clone git@github.com:litten/hexo-theme-yilia.git 2.主题基本配置 注意，主题配置修改的都是themes/yilia/_config.yml，配置项不一一解释了 3.头像和打赏配置（1）图片的位置 图片应该放在当前博客下面，比如我建了一个img文件夹，图片就放在里面，如下图所示： （2）具体配置 1234567891011#打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: &apos;谢谢你请我吃糖果&apos;# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: /img/alipay.png# 微信二维码图片地址weixin: /img/wepay.png# 头像地址avatar: /img/avatar.jpg ​ 三、博客的基本配置 注意：这里修改的都是最外层的_config.yml（不是themes文件夹里面） 1.所有文章 在_config.yml中配置如下，不加的话，点击所有文章会报错 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 2.部署配置 配置到github对应的仓库中 在_config.yml中配置如下： 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 四、高级功能配置1、网站访问量显示（1）效果 （2） 实现 使用了不蒜子第三方的统计插件，网址：http://ibruce.info/2015/04/04/busuanzi/ 在themes\\yilia\\layout_partial下的footer.ejs中加入如下代码即可，如下所示： 12345678910111213141516171819202122&lt;footer id=&quot;footer&quot;&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt; Theme &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot;&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/footer&gt;&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 2、评论功能（1）效果 （2）实现 去来必力网站注册账号，https://livere.com/ 网站给的代码，如图 插入的代码需要调整下边距，不然下面的第三方登录按钮会被覆盖导致错位，我加的代码如下 1style=&quot;margin: 0 50px 0 50px&quot; 最后在themes\\yilia\\layout_partial下的article.ejs将改代码添加到&lt;% if (theme.wangyiyun){ %&gt;前面 12345678910111213141516171819202122232425&lt;!-- 来必力City版安装代码 --&gt; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;MTAyMC8zMTIwOS83NzU4&quot; style=&quot;margin: 0 50px 0 50px&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt; &lt;/div&gt; &lt;!-- City版安装代码已完成 --&gt; &lt;% if (theme.wangyiyun)&#123; %&gt; &lt;%- partial(&apos;post/wangyiyun&apos;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;% &#125; %&gt; 五、域名绑定1、申请域名 本人是在阿里云上面申请的域名，注意.com域名不需要备案，.cn是国内域名，需要备案 2、域名解析 ping username.github.io，来获取你的空间的ip 添加CNAME类型的解析 添加结果如图： 3、配置到github 在博客的根目录下新建一个CNAME文件 填写申请的域名，xxx.com push到github即可 六、感谢 本文参考了Lawlite的：Hexo+Github搭建自己的博客并按照步骤一步步搭建，几个模块的搭建方法有些许不同，在Lawlite的基础上做了修改，编写了这篇博客！","tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","date":"2017-10-05T08:00:03.681Z","path":"2017/10/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]